{"version":3,"sources":["../src/index.js"],"names":["isCSS","name","test","strip","str","replace","nameInterpolator","input","file","content","index","res","context","resourcePath","normalizeImports","preserve","TypeError","CSSSplitWebpackPlugin","size","imports","filename","defer","options","key","asset","sourceAndMap","source","getName","i","process","map","prev","then","result","Promise","resolve","chunks","css","toString","compilation","done","assets","publicPath","output","promises","chunk","files","filter","items","all","entries","forEach","entry","length","push","_name","join","splice","indexOf","compiler","plugin","chunksMapping"],"mappings":"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","file":"index.js","sourcesContent":["import postcss from 'postcss';\nimport chunk from './chunk';\nimport {SourceMapSource, RawSource} from 'webpack-sources';\nimport {interpolateName} from 'loader-utils';\n\n/**\n * Detect if a file should be considered for CSS splitting.\n * @param {String} name Name of the file.\n * @returns {Boolean} True if to consider the file, false otherwise.\n */\nconst isCSS = (name : string) : boolean => /\\.css$/.test(name);\n\n/**\n * Remove the trailing `/` from URLs.\n * @param {String} str The url to strip the trailing slash from.\n * @returns {String} The stripped url.\n */\nconst strip = (str : string) : string => str.replace(/\\/$/, '');\n\n/**\n * Create a function that generates names based on some input. This uses\n * webpack's name interpolator under the hood, but since webpack's argument\n * list is all funny this exists just to simplify things.\n * @param {String} input Name to be interpolated.\n * @returns {Function} Function to do the interpolating.\n */\nconst nameInterpolator = (input) => ({file, content, index}) => {\n  const res = interpolateName({\n    context: '/',\n    resourcePath: `/${file}`,\n  }, input, {\n    content,\n  }).replace(/\\[part\\]/g, index + 1);\n  return res;\n};\n\n/**\n * Normalize the `imports` argument to a function.\n * @param {Boolean|String} input The name of the imports file, or a boolean\n * to use the default name.\n * @param {Boolean} preserve True if the default name should not clash.\n * @returns {Function} Name interpolator.\n */\nconst normalizeImports = (input, preserve) => {\n  switch (typeof input) {\n  case 'string':\n    return nameInterpolator(input);\n  case 'boolean':\n    if (input) {\n      if (preserve) {\n        return nameInterpolator('[name]-split.[ext]');\n      }\n      return ({file}) => file;\n    }\n    return () => false;\n  default:\n    throw new TypeError();\n  }\n};\n\n/**\n * Webpack plugin to split CSS assets into multiple files. This is primarily\n * used for dealing with IE <= 9 which cannot handle more than ~4000 rules\n * in a single stylesheet.\n */\nexport default class CSSSplitWebpackPlugin {\n  /**\n   * Create new instance of CSSSplitWebpackPlugin.\n   * @param {Number} size Maximum number of rules for a single file.\n   * @param {Boolean|String} imports Truish to generate an additional import\n   * asset. When a boolean use the default name for the asset.\n   * @param {String} filename Control the generated split file name.\n   * @param {Boolean} defer Defer splitting until the `emit` phase. Normally\n   * only needed if something else in your pipeline is mangling things at\n   * the emit phase too.\n   * @param {Boolean} preserve True to keep the original unsplit file.\n   */\n  constructor({\n    size = 4000,\n    imports = false,\n    filename = '[name]-[part].[ext]',\n    preserve,\n    defer = false,\n  }) {\n    this.options = {\n      size,\n      imports: normalizeImports(imports, preserve),\n      filename: nameInterpolator(filename),\n      preserve,\n      defer,\n    };\n  }\n\n  /**\n   * Generate the split chunks for a given CSS file.\n   * @param {String} key Name of the file.\n   * @param {Object} asset Valid webpack Source object.\n   * @returns {Promise} Promise generating array of new files.\n   */\n  file(key : string, asset : Object) {\n    // Use source-maps when possible.\n    const input = asset.sourceAndMap ? asset.sourceAndMap() : {\n      source: asset.source(),\n    };\n    const getName = (i) => this.options.filename({\n      ...asset,\n      content: input.source,\n      file: key,\n      index: i,\n    });\n    return postcss([chunk(this.options)]).process(input.source, {\n      map: {\n        prev: input.map,\n      },\n    }).then((result) => {\n      return Promise.resolve({\n        file: key,\n        chunks: result.chunks.map(({css, map}, i) => {\n          const name = getName(i);\n          const result = map ? new SourceMapSource(\n            css,\n            name,\n            map.toString()\n          ) : new RawSource(css);\n          result.name = name;\n          return result;\n        }),\n      });\n    });\n  }\n\n  chunksMapping(compilation, chunks, done) {\n    const assets = compilation.assets;\n    const publicPath = strip(compilation.options.output.publicPath || './');\n    const promises = chunks.map((chunk) => {\n      const input = chunk.files.filter(isCSS);\n      const items = input.map((name) => this.file(name, assets[name]));\n      return Promise.all(items).then((entries) => {\n        entries.forEach((entry) => {\n          // Skip the splitting operation for files that result in no\n          // split occuring.\n          if (entry.chunks.length === 1) {\n            return;\n          }\n          // Inject the new files into the chunk.\n          entry.chunks.forEach((file) => {\n            assets[file.name] = file;\n            chunk.files.push(file.name);\n          });\n          const content = entry.chunks.map((file) => {\n            return `@import \"${publicPath}/${file._name}\";`;\n          }).join('\\n');\n          const imports = this.options.imports({\n            ...entry,\n            content,\n          });\n          if (!this.options.preserve) {\n            chunk.files.splice(chunk.files.indexOf(entry.file), 1);\n            delete assets[entry.file];\n          }\n          if (imports) {\n            assets[imports] = new RawSource(content);\n            chunk.files.push(imports);\n          }\n        });\n        return Promise.resolve();\n      });\n    });\n    Promise.all(promises).then(() => {\n      done();\n    }, done);\n  }\n\n  /**\n   * Run the plugin against a webpack compiler instance. Roughly it walks all\n   * the chunks searching for CSS files and when it finds one that needs to be\n   * split it does so and replaces the original file in the chunk with the split\n   * ones. If the `imports` option is specified the original file is replaced\n   * with an empty CSS file importing the split files, otherwise the original\n   * file is removed entirely.\n   * @param {Object} compiler Compiler instance\n   * @returns {void}\n   */\n  apply(compiler : Object) {\n    if (this.options.defer) {\n      // Run on `emit` when user specifies the compiler phase\n      // Due to the incorrect css split + optimization behavior\n      // Expected: css split should happen after optimization\n      compiler.plugin('emit', (compilation, done) => {\n        return this.chunksMapping(compilation, compilation.chunks, done);\n      });\n    } else {\n      // Only run on `this-compilation` to avoid injecting the plugin into\n      // sub-compilers as happens when using the `extract-text-webpack-plugin`.\n      compiler.plugin('this-compilation', (compilation) => {\n        compilation.plugin('optimize-chunk-assets', (chunks, done) => {\n          return this.chunksMapping(compilation, chunks, done);\n        });\n      });\n    }\n  }\n}\n"]}